# 2018년 1월 8일

## 1. Postman

1. makes API development faster, easier, and better.
2. Postman을 이용하면 REST API를 간편하게 시험해볼 수 있으며, 다양한 편의기능을 제공한다.
3. REST API를 사용할 때, 먼저 Postman을 통해 잘 동작하는지 실험한 후에 코드로 옮기는 것이 좋다. 잘못 동작할 경우에 바로 프로그램으로 옮기면 문제가 생길수도 있기 때문이다.
4. 다음 코드처럼 REST API로 요청을 보내는 함수를 만들어서 사용할 수도 있다.

   ```javascript
   function fetchIssuesByUser(username) {
     return fetch(`https://api.github.com/repos/fds7/fds-handouts/issues?creator=%{username}`)
   }
   ```

## 2. HTTP

1. HTTP는 **웹 브라우저와 웹 서버 간의 통신**을 위해 개발된 통신규약이다.
2. 최근에는 **REST API의 부상**과 함께 다른 용도로도 널리 사용된다.
   1. 모바일 앱 - 서버 간 통신
   2. 서버 - 서버 간 통신
3. **80번 포트**를 기본으로 사용한다. http 프로토콜을 사용중인 경우 이미 80번 포트를 사용중인 것이다.
4. 클라이언트의 **요청(request)**과 서버의 **응답(response)**으로 이루어진다.
5. Chrome 개발자 도구의 Network 탭에서 브라우저가 해당 웹사이트 서버에 요청하여 응답받은 자료들을 확인할 수 있다. 요청에 대한 응답 항목의 갯수만큼 http 통신이 이뤄진 것이다.

### 2.1 HTTP의 역사

1. (1991) - HTTP 초기버전 발표. **텍스트만 전송**할 수 있는 극도로 단순한 프로토콜. 1990년대 초 인터넷 붐을 일으킴
2. (1996) - 여러 인터넷 서비스 업체들이 자체적으로 사용하던 HTTP 구현들을 모아 HTTP 1.0 발표
3. (1999) - 1.0의 문제를 해결하고 여러가지 기능을 추가한 HTTP 1.1을 발표. **지금까지 사용되고 있는 버전**
4. [Brief History of HTTP](https://hpbn.co/brief-history-of-http/)

### 2.2 HTTPS

1. HTTP over SSL
2. HTTP 통신을 암호화해 주고받는 내용을 중간에서 가로챌 수 없도록 하였다.
3. **443번 포트**를 기본으로 사용한다.
4. 클라이언트와 서버의 통신에 http 프로토콜을 사용한다면, 해커가 공유기를 해킹했을 때 둘 사이에 이뤄지는 모든 통신에 대한 정보를 알 수 있다. 암호와 같은 개인정보를 전송한다면 해커가 그 정보를 가로챌 수 있다는 것이다. https 프로토콜은 클라이언트와 서버만이 사용할 수 있는 일종의 잠열쇠를 가지고 통신하기 때문에 해커가 중간에서 가로채더라도 내용을 확인할 수 없다. 이러한 이유로 무조건 https를 쓰는 것이 좋다.
5. 최근 들어 개인 정보를 다루는 모든 사이트는 https를 사용하도록 하는 법이 만들어졌다.
6. 그러나 https를 사용하려면 많은 돈이 필요했다. 이에 Mozilla 재단의 주도 하에 누구든 https를 편하게 쓸 수 있도록 하는 방법을 만들자는 움직임이 생겨났고, 이제 우리는 돈을 내지 않더라도 아주 편하게 https를 사용할 수 있다.

### 2.3 HTTP/2

1. **구글의 SPDY 프로토콜**을 기반으로 2015년에 확정된 새로운 HTTP 표준이다.
2. **속도 개선**에 중점을 두고 개발되었다.
3. **반드시 HTTPS를 사용해야 한다.**
4. [현재 전체 웹사이트 중 16% 이상이 사용 중](https://w3techs.com/technologies/details/ce-http2/all/all)이다.
5. HTTP 1.1은 99년도에 만들어졌는데,  그 이후에 컴퓨터에는 엄청난 발전이 있었다. 이 기간동안 브라우저는 프로토콜을 잘 발전시킬 수 있을 만큼 안정적이지 않았고, HTTP 1.1은 여전히 사용하기 쉬웠기 때문에 아무런 문제없이 계속해서 잘 쓰일 수 있었던 것이다. 안정된 단계에 접어들고 프로토콜을 발전시키기 위한 논의가 진행되면서 구글에서 HTTP를 훨씬 더 발전시킨 프로토콜을 새롭게 채택하자고 해서 나오게 되었다.
6. HTTP/2 이전에는 클라이언트가 요청을 했을 때에만 응답을 보내주었다. 즉 요청을 주기 전에 서버는 응답하지 않는다. 그러나 HTTP/2는 클라이언트가 요청을 보내지 않더라도 서버가 응답하는 기능이 포함되어 속도가 굉장히 빨라졌다.
7. HTTP/2에는 헤더에 무조건 소문자를 쓴다는 규칙이 추가되었다. 특정 웹사이트가 HTTP/1.1 또는 HTTP/2를 쓰는지 확인하고 싶다면 개발자 도구의 네트워크 탭에서 헤더 부분을 확인하면 된다.
8. [나만 모르고 있던 HTTP/2](http://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-http2/)

### 2.4 Request & Response

1. 웹 브라우저(또는 다른 클라이언트)는 웹 서버에 요청(request)를 보낸다.
2. 그에 따라 서버는 클라이언트에 응답(response)를 보낸다.
3. 웹 브라우저의 경우, **HTML 문서 형태의 응답**이 오면 해당 문서를 분석한 후, **문서에 포함된 모든 자원에 대한 요청을 각각 추가로 보낸다**(이미지, 동영상, 오디오, CSS, JS, 폰트, ...). 한 번에 모든 요청을 보내지만 애초부터 이런 방식으로 설계되었다.

### 2.5 Request Methods

1. [HTTP 명세에는 8 종류](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)가 등록되어 있고, 각각의 역할과 충족해야 하는 성질이 명시되어 있다.
2. 웹 브라우저는 **특정 상황에서 특정 메소드로 요청을 보내도록 만들어져 있다.**
3. Ajax와 같이 **요청을 보내는 코드를 직접 짤 때**는 요청 메소드를 선택할 수 있다.
4. **자료의 본문을 요청하는 GET** 메소드와, **새로운 자료를 등록하는 POST** 메소드가 가장 많이 쓰인다.
5. html에서 form을 사용하지 않으면 get 요청만 보낼 수 있다.
6. 자바스크립트를 사용하면 다른 메소드로의 요청도 보낼 수 있다.
7. HEAD 메소드는 자료의 본문은 빼고 요청한 주소에 들어있는 자원에 대한 부가 정보만 요청한다.
8. PUT 메소드는 자료를 통째로 교체하고자 할 때 사용한다.
9. [HTTP Method Definitions](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)

### 2.6 (서버가 충족시켜야 하는) 메소드의 성질

1. Safe: 요청이 서버의 상태에 영향을 미치지 않아야 한다. 즉, **읽기 전용**이어야 한다. 예를 들어, GET 메소드는 읽기 전용이어야 한다. GET 메소드로 요청을 보냈을 때 서버의 자료가 수정되면 안된다.
2. Idempotent(멱등성): 여러 번 같은 요청을 해도 한 번 요청한 것과 같은 효과여야 한다. **네트워크가 불안정해도 안전하게 요청을 보낼 수 있다.**
3. Cacheable: (특정 조건을 만족하면) 응답을 클라이언트에 저장해두었다가 다음 번 요청 때 **다시 쓸 수 있다.**
4. POST는 첫 번째 요청이 실패해서 두 번 보내진건지, 의도적으로 두 번 보낸건지 알 수 없으므로  Idempotent하면 안된다고 약속하고 사용한다. 또한 No Cacheable이어야 한다(표에 Yes로 표기된 부분은 오류이다).
5. PUT은 자료를 통째로 바꾸기 위해서 사용한다. 따라서 자료를 통째로 바꾸면 결과는 똑같을 것이므로 Idempotent하다. 
6. PATCH는 자료의 일부만 바꾸기 위해서 사용한다.
7. 반드시 이 성질을 따르도록 서버를 구현해야 하는 것은 아니나, 구현했을 때의 이점이 있으므로 이대로 구현하는 것이 좋다.
8. https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Summary_table

> ##### PATCH가 Non Idempotent한 이유는?
>
> 1. PATCH 메소드로 요청을 보냈을 때 특정 필드의 값을 1씩 증가시켜준다고 하자. 이때 요청의 횟수에 따라 증가 횟수가 정해지므로 매 요청마다 값은 달라진다.

### 2.7 URL

1. [URL Anatomy](https://cascadingmedia.com/insites/2015/02/url-anatomy-seo-tips.html)

### 2.8 Percent Encoding

1. URL은 **ASCII 문자**(128개의 영문자+특수문자+제어문자)밖에 사용하지 못하기 때문에, non-ASCII 문자를 위한 표현방법이 필요하다.
2. Percent encoding은 non-ASCII 문자를 위한 웹 표준 인코딩 방법으로, JavaScript에 관련 기능이 포함되어 있다.

   ```javascript
   encodeURIComponent("한글") // "%ED%95%9C%EA%B8%80"
   decodeURIComponent("%ED%95%9C%EA%B8%80") // "한글"
   ```

3. 구글에서 한글로 ''자바스크립트''를 검색하면 주소 문자열에는 잘 나타나지만, 그것은 구글에서 한글로 잘 보여지도록 처리한것이다. 실제로는  'q=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8'으로 전송된다. 이렇게 전송된 값이 perecent encoding으로 변환한 결과이다.

   ```javascript
   decodeURIComponent('q=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8')
   // "q=자바스크립트"

   encodeURIComponent('자바스크립트')
   // "%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8"
   ```

4. 비슷한 기능을 하는 것으로 `decodeURI`도 있지만 유의미한 차이점이 있다. `decodeURIComponent`로 써야 한다.
5. **encodeURIComponent()는 인수를 쿼리스트링의 일부라고 간주한다. 따라서 =, ?, &를 인코딩한다. 반면 encodeURI()는 인수를 URI 전체라고 간주하며 파라미터 구분자인 =, ?, &를 인코딩하지 않는다.**

### 2.9 Request Target

1. 일반적인 경우 아래와 같은 구조가 사용된다.

   ```bash
   # absolute path + query string + fragment id
   GET /path/to/resource?foo=bar&spam=hoge#fragid HTTP/1.1
   ```

2. 리퀘스트 타겟에 도메인은 포함되지 않는다.
3. HTTP/1.1은 텍스트 기반의 프로토콜로 위의 전송 문자열 자체가 전송된다. 반면 HTTP/2는 훨씬 더 압축이 되어 전송된다. 따라서 속도는 훨씬 더 빨라진다.

### 2.10 Response Status

1. 응답의 성공, 실패 여부와 종류를 나타내며, **상태 코드 + 상태 메시지**의 형태로 응답에 포함된다.

   ```bash
   HTTP/1.1 200 OK
   ```

2. [HTTP Status Codes](https://httpstatuses.com/)
3. http1.1의 경우 위처럼 응답 텍스트를 받아오지만 http2는 010101과 같은 형태로 받는다.

### 2.11 Status Category

1. 2xx: 성공
2. 3xx: 추가 작업이 필요함
3. 4xx: 실패 - 클라이언트 책임
4. 5xx: 실패 - 서버 책임
5. 특정 사이트에 두 번째로 접속할 때 이미 한 번 받아온 적 있던 css, javascript 파일을 두 번 받아올 필요가 없다. 그때 서버가 주는 응답 코드가 304이다. 자료가 변하지 않았으므로 원래 가지고 있던 것을 그대로 쓰면 된다는 뜻이다.
6. 이런 부분을 위해 내가 지금 갖고 있는 자료가 무엇인지 서버에 알려줄 필요가 있는데 그 정보들은 헤더에 포함되어 있다. 헤더에 있는 ETag 혹은 다른 정보를 바탕으로 하여 지금 내가 갖고 있는 자원의 정보와 서버의 것을 비교하고 달라졌으면 200을, 달라지지 않았으면 304 코드를 전송한다.

#### 2.12.1 Status Code - 2xx

1. 200 OK: 성공
2. 201 Created: 자료가 성공적으로 생성됨

#### 2.12.2 Status Code - 3xx (추가 작업)

1. 301 Moved Permanently (Redirection): 자료가 완전히 다른 곳으로 이동했으므로 다른 곳을 알아봐야 함
2. 302 Found (Redirection): 자료가 일시적으로 다른 곳에 있음
3. 304 Not Modified (Cache): 클라이언트가 이미 가지고 있던 자료가 수정되지 않았음 (그대로 사용하면 됨)

## 3. 파이어베이스

1. 구글 인증 기능을 사용하려면 파이어베이스 Console에서 [Develop] - [로그인 방법] -[Google] - [사용 설정] - [저장] 순으로 진행한다.
2. [Google 로그인으로 인증하기](https://firebase.google.com/docs/auth/web/google-signin)
3. 인증된 사용자마다 각자의 데이터베이스를 갖도록 하는 서비스를 만들기 위해 다음 부분을 생각해야 한다.
   1. 데이터베이스의 구조를 어떻게 설계할 것인가?
   2. 데이터베이스의 구조에 따른 보안 규칙은 어떻게 설정한 것인가?
4. 보안 규칙을 설정하지 않으면 특정 데이터베이스에 누구나 접근할 수 있다.
5. 파이어베이스 앱은 기본적으로 이메일 주소가 같다면 동일 계정으로 취급한다 즉, Google, Facebook 또는 Github 중 어떤 계정으로 로그인하던 간에 해당 계정에서 제공하는 이메일 주소가 같다면 동일 계정으로 취급한다. 로그인 방법이 달라도 같은 사용자로 로그인한 것일 수도 있는 것이다(설정에서 변경 가능).
6. Firebase 사용자를 유일하게 식별할 수 있는 식별자로 누구를 쓸 것인가? `uid`로 사용자를 유일하게 식별할 수 있다.
7. 이메일도 식별자로 사용할 수 있겠지만 다음 두 가지 이유에서 권장되지 않는다.
   1. 사용자가 이메일을 변경할 수도 있다.
   2. Facebook은 이메일 뿐만 아니라 전화번호를 가지고도 사용자를 관리한다. 즉, 이메일을 갖지 않더라도 전화번호로 페이스북 가입이 가능한 것이다.
8. 이메일, 전화번호는 사용자의 속성일 뿐이지 사용자를 유일하게 식별할 수 있는 값은 아니다.
9. 파이어베이스 앱에서 로그인을 하게 되면 해당 사용자를 나타내는 유일한 uid가 생성된다. 유저 객체를 잘 살펴보면 `uid`를 확인할 수 있다.

   ```json
   {
     "users": {
       "uid": {
         "todos": {
           "todo identifier": {
             "title": "파이어베이스 공부",
             "complete": false
           }
         }
       }
     }
   }
   ```

10. 보안 규칙을 직접 설정해줘야 특정 사용자가 다른 데이터베이스에 접근하지 못 하도록 할 수 있다.
11. `push()` 메소드를 이용하여 데이터를 추가할 수 있다.
12. `onAuthStateChanged`가 호출되는 시점은 다음과 같다.
    1. 처음 로그인했을 때
    2. 로그인 후 다시 페이지를 열었을 때
    3. 로그아웃했을 때

> ##### 1. netlify를 통하여 파이어베이스 앱 배포하기
>
> 1. netlify를 통해 파이어베이스 앱을 배포할 때 [파이어베이스 Console] - [Develop] - [Authentication]- [승인된 도메인]에 netlify 주소를 등록해야만 인증 오류가 뜨지 않는다.
> 2. netlify에서 배포하고자 하는 github 저장소에 index.html 파일이 있으면 따로 build 커맨드를 지정하지 않아도 바로 실행된다.
>
> ##### 2. Chrome Secret Mode
>
> 1. 웹 개발을 할 때, 브라우저에 쿠키가 남아있다면 개발 과정에 영향을 미칠 수도 있다. 이때 Chrome 브라우저의 시크릿 탭을 이용하면 마치 브라우저를 새로 설치한 것처럼 작동시킬 수 있어서 매우 유용하다. Chrome 브라우저 우측 상단의 ... 버튼에서 새 시크릿 창을 클릭하거나 `CMD + SHIFT + N`으로 시크릿 모드를 실행할 수있다.

## 4. BEM

1. 요소들을 둘러싼 큰 상자를 Block이라고 부른다.
2. 타겟팅을 해서 쓸 요소들을 Element라고 부른다.
3. 로그인이 된 상태이면 로그인 박스가 필요없다. 클래스가 상태를 나타낼 때도 있으므로 이것을 Modifier라고 부른다.
4. SASS를 이용하면 BEM의 긴 클래스명을 효율적으로 쓸 수 있는 방법이 있다.
5. 두 개 이상의 Block이 중첩되었을 때 작은 블록을 기준으로 하라는게 BEM에서의 권장사항이다.
6. BEM은 명확한 역할과 명확한 기능이있는 요소에 대해서 적용하는 것이고, BEM을 사용하고 있더라도 재사용 가능한 클래스는 따로 작성해서 사용할 수도 있다. 모든 경우에 BEM을 쓰라는 것은 아니다.
7. 따라서 범용으로 쓰이는 유틸리티 클래스는 그냥 쓰면 Block 이름처럼 보여 헷갈릴 수 있으므로, BEM에서의 권장사항은 아니지만 보통 `.u-hidden`으로 짓는 기법이 있다.

## 5. 비관적 업데이트(Pessimistic Update)와 낙관적 업데이트(Optimistic Update)

1. 우리가 만든 파이어베이스 앱에서 요청을 보낸 후 응답을 받기 전까지는 요청이 잘 전송되었는지 확인할 방법이 없다. 프론트엔드 개발자는 "데이터가 잘 저장됬는지 확인 후 결과를 화면에 보여줄 것인가, 데이터가 잘 저장되었는지 확인하기 전에 단순히 빨리 동작하는 것이 좋은가" 사이에서 고민해야 한다. 상황에 따라 적절하게 선택하면 된다.
2. 비관적 업데이트(Pessimistic Update): 데이터가 저장된 것을 확인하고 나서 화면을 그려주는 업데이트 방식을 말한다. 비관적 업데이트를 하더라도 사용자에게 기다려달라는 표시로 적절한 **로딩 인디케이터**를 사용할 수 있다.
3. 낙관적 업데이트(Uptimistic update): 데이터가 저장되었는지 확인하지도 않고 화면부터 업데이트해주는 방식을 말한다.
4. 비동기 작업을 할 때는 가능하다면 사용자가 지루하지 않도록 시작과 끝에 로딩 인디케이터 작업을 해주는 것이 좋다.
