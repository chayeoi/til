# 3 Day

## 1. 통신방식의 분화

1. 기존의 앱에서 API를 구현할 때는 REST API가 사용되었는데, 최근들어 REST API의 단점을 보완한 GraphQL이 등장했다.
2. REST API는 내가 가져오고 싶은 요청의 갯수만큼 요청을 보내야해서 힘들다는 문제가 있었고 GraphQL이 이 문제를 해결했다.
3. 여전히 REST API가 제일 많이 쓰이긴 하지만, 다른 쪽으로도 많이 옮겨가고 있다.

<br />

<br />

## 2. Cache

### 2.1 Cache

1. Cache는 사전적으로 `(무기 등의) 은닉처, 은닉하다`의 의미를 갖고 있다.
2. 컴퓨터 분야에서의 캐시는 (주로 접근 속도의 개선을 위해) **데이터를 미리 복사해 놓는 임시 저장소**, 혹은 **그 임시 저장소에 데이터를 저장하는 행위**를 가리킨다.
3. 'cache' 혹은 'caching'이라는 **용어 자체는 특정 기술을 가리키는 것이 아니라,** 접근 속도를 개선하기 위해 따로 저장소를 두는 '방법'을 가리킨다.
4. 컴퓨터의 **아주 많은 부분**(CPU, GPU, HDD, 네트워크, 웹, 데이터베이스...)에서 사용되고 있다.

<br />

### 2.2 HTTP Cache

1. 자원의 효율적 로딩을 위한 [웹 표준](https://tools.ietf.org/html/rfc7234)이다.
2. **서버에서 가져온 자원**(HTML, CSS, JS, 이미지, ...)을 **가까운 곳**(브라우저, 혹은 다른 서버)에 저장해놓고 재사용한다.
3. 캐시를 할 것인지 말 것인지, 어떻게 할 것인지를 결정하는 규칙이 복잡하고, 브라우저마다 조금씩 다르다.
4. 캐시가 저장되는 곳은 컴퓨터 어딘가일수도 있고 통신에서 각각의 계층 사이에 있을수도 있다.
5. 브라우저 캐시는 컴퓨터의 하드디스크에 저장된다.

<br />

### 2.3 캐시된 자원과 실제 자원의 내용이 달라지는 문제를 어떻게 해결할 것인가?

1. 캐시는 주소 단위로 캐시된다. 클라이언트가 특정 홈페이지의 index.html을 갖고 있는 상황에서 해당 홈페이지의 index.html이 업데이트되었을 때, 클라이언트는 업데이트된 내용을 확인하고 새로운 index.html을 받을 수 있어야 한다. 이 문제를 해결하기 위해 http 캐시는 두 가지 방법으로 접근하고 있다.
   1. 첫 번째 방법으로, 자료의 캐시 명령에 대한 응답 헤더를 포함시켜서 자료의 유효 기간을 설정할 수 있다. 같은 주소로 요청이 일어났을 때 설정한 유효 기간이 지나지 않았다면 브라우저는 정해진 기간동안 계속 캐시를 사용한다. 그러나 이 방법은 자료의 변경이 일어났을 때 그것을 반영할 방법이 없으므로 위험하다. 그러나 서버를 열심히 최적화하는 회사라면, 서버로의 요청이 줄어들어 비용이 감소할 수 있는 방법이므로 위 방법을 사용하기도 한다.
   2. 두 번째 방법은, 서버가 클라이언트로부터 요청을 받고 자료를 전송할 때 헤더에 E-Tag를 포함시켜서 보내는 방법이다. 자원의 이름을 V1이라고 했을 때, 이 태그 안에 들어있는 정보는 이 V1이라는 **특정 자원의 내용에 대한 식별자**이다(자원의 위치에 대한 식별자는 주소이다). 원래대로라면 자원의 주소로 요청이 발생했을 때 응답의 바디 부분에 필요한 내용을 포함시켜서 보내주는데, 브라우저가 If-None-Match: V1을 요청에 포함해서 보내고 이때 변경이 없다면 서버는 바디에 해당 내용을 바디에 포함하지 않고 보냄으로써 네트워크 트래픽을 줄일 수 있다. 이런 상황에서 서버가 보내주는 응답 코드 및 메세지가 (304 not modified)이다.

<br />

#### 2.3.1 Solution

1. Expiration(만료): 정해진 시간이 지나면 **캐시가 자동으로 삭제**되도록 설정
2. Validation (검증): 서버에 요청을 보내서 **캐시를 계속 사용할 수 있는지 확인**

<br />

### 2.4 Cache 관련 헤더

1. Cache-Control: (요청, 응답) 캐시와 관련된 다양한 기능을 하는 지시자를 포함한다. no-cache, max-age가 자주 사용된다. no-cache, max-age=0 지시자는 캐시를 사용하지 않도록 하거나, 캐시를 아직도 쓸 수 있는지 검증하기 위해 사용된다[(각각의 자세한 의미)](https://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache).
2. ETag: (응답) 캐시의 검증을 위해 사용되는 자원의 식별자이다. 주로 자원의 [해시값](https://namu.wiki/w/%ED%95%B4%EC%8B%9C)이 사용되나, 마지막으로 수정된 시각, 혹은 버전 넘버를 사용하기도 한다.
3. Expires: (응답) 캐시를 만료시킬 **시각**을 서버에서 명시적으로 지정한다.
4. Last-Modified: (응답) 원래 자료가 마지막으로 수정된 시각을 나타낸다.
5. If-None-Match: (요청) 검증을 위해 사용된다. 이전에 저장해두었던 자원의 **ETag** 값을 If-None-Match 헤더의 값으로 요청에 포함시켜서 보내면, 서버는 해당 경로에 있는 자원의 ETag와 **비교**해보고 자원의 전송 여부를 결정한다.
6. If-Modified-Since: (요청) 검증을 위해 사용된다. 이전에 저장해두었던 자원의 **Last-Modified** 값을 If-Modified-Since 헤더의 값으로 요청에 포함시켜서 보내면, 서버는 해당 경로에 있는 자원의 Last-Modified와 **비교**해보고 자원의 전송 여부를 결정한다.
7. [MDN - Caching  관련 헤더](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers#Caching)
8. [MDN - Conditionals 범주](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers#Conditionals)

<br />

> 개발자 도구의 네트워크 탭에서 Disable cache에 체크하면 절대 캐시되지 않는다.

<br />

### 2.5 해싱(Hashing)

1. 컴퓨터 공학에선 어떤 자원이 변경되었는지 알기 위해서 비교를 해야하는 작업이 자주 발생한다.
2. 만약에, 두 자원 v1과 v2에 대하여 둘을 비교할 필요가 있지만 둘이 굉장히 멀리 떨어져있어서 네트워크 비용이 많이 발생한다면 일일이 비교하는 것은 큰 낭비가 될 것이다. 그래서 모든 부분을 다 비교할 필요 없이 비교하려는 대상들의 내용을 각각 짧은 문자열로 계산하는 연산이 매우 자주 쓰이는데, 이 작업을 해싱(Hashing)이라고 한다.
3. 해싱을 통해 계산한 결과를 해시(Hash)라고 한다. 어떤 자료의 상태가 아주 조금만 바뀌었더라도 해시 값은 완전히 달라진다. 따라서 클라이언트가 가지고 있는 자료와 서버에서 보내려하는 파일을 비교하기 위해서 해시(Hash)만 비교하면 된다. ETag가 바로 해시 형태로 되어 있다. 따라서 브라우저의 If-None-Match가 서버의 ETag 값과 같으면 자료를 다시 보내주지 않아도 되고 다르다면 새로운 자료를 보내준다.
4. 해시를 생성해주는 함수의 종류는 굉장히 많다(MD5 Calcaulator 등).
5. git에서 commit 이력을 확인했을 때에 등장하는 값들 역시 해시(Hash)이다.

<br />

<br />

## 3. JSON Web Token, JWT

1. JWT는 해시를 사용한다.
2. Base 64 인코딩 방식이 있는데 이 방식은 무손실이라서 값을 복구할 수 있다. 이들은 해시가 아니다.
3. 어떤 회사가 Base 64 인코딩을 이용한 토큰을 사용하고 있다는 걸 해커가 알아채는 순간, 토큰을 어떻게 만들었는지만 알 수 있다면 해커 자신이 토큰을 만들어낼 수 있으므로 자신이 특정 사용자인것처럼 행세할 수 있게 된다. 따라서 토큰에 적합하지 않은 방식이다.
4. 토큰에 정보를 담되, 우리 회사말고는 토큰을 만들지 못하도록 하면 해커는 토큰을 만들 방법이 없다. 그 방법으로 해시를 사용할 수 있다. 각 유저의 uid에 우리 회사만 알고 있는 시크릿 코드를 이어붙여서 해시를 만들어내면, 해당 시크릿 코드를 모르는 해커는 똑같은 토큰을 만들어낼 수 없을 것이다. 이러한 방식으로 해커가 새로 토큰을 만들어내거나 하는 등의 토큰의 조작을 방지할 수 있다. 이 시크릿 코드를 서명(Signature)이라고 한다. 즉, 서명은 토큰의 조작을 방지하는 방법이다. 이 서명은 마치 양념을 치는 것과 같아서 그러한 뜻에서 salt라고 부른다. 서명은 절대 외부로 알려지지 않게 잘 관리해야 한다.
5. [Velopert - JSON Web Token 소개 및 구조](https://velopert.com/2389)

<br />

<br />

## 4. Firebase storage 

### 4.1 페이지네이션(Pagination) 

1. 파이어베이스의 데이터 필터링 메소드를 사용하면 가져오고 싶은 항목들만 선택적으로 가져올 수 있다.
2. 필터링 메소드를 사용하려면 정렬이 선행되어야한다.
3. 파이어베이스의 실시간 데이터베이스는 내림차순 정렬이 불가능한 대신, 자료의 끝부터 몇 개씩 가져오는 방식으로 값을 가져올 수 있다.
4. 페이지네이션과 같이 반복되는 작업을 되돌리기 위해서 스택을 활용할 수 있다.
5. Firebase CLI는 커맨드 라인에서 사용할 수 있는 도구로, 파이어베이스와 관련된 기능을 터미널에서 사용할 수 있도록 해준다.
6. Firebase CLI를 통해 netlify 서비스와 비슷한 Firebase Hosting을 사용할 수 있다.

| 메소드              | 용도                                       |
| ---------------- | ---------------------------------------- |
| `limitToFirst()` | 정렬된 결과 목록에서 맨 처음부터 반환할 최대 항목 개수를 설정합니다.  |
| `limitToLast()`  | 정렬된 결과 목록에서 맨 끝부터 반환할 최대 항목 개수를 설정합니다.   |
| `startAt()`      | 선택한 정렬 기준 메소드에 따라 지정된 키 또는 값보다 크거나 같은 항목을 반환합니다. |
| `endAt()`        | 선택한 정렬 기준 메소드에 따라 지정된 키 또는 값보다 작거나 같은 항목을 반환합니다. |
| `equalTo()`      | 선택한 정렬 기준 메소드에 따라 지정된 키 또는 값과 동일한 항목을 반환합니다. |

