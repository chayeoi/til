# 2장: TCP의 구성요소

인터넷의 중심에는 두 개의 프로토콜 IP와 TCP가 존재한다. IP(Internet Protocol)는 호스트에서 호스트로의 라우팅과 주소할당(addressing) 기능을 제공하고 TCP(Trnsmission Control Protocol, 전송 제어 프로토콜)는 신뢰성을 보장해주는 네트워크 기능을 제공한다. TCP/IP는 통상 인터넷 표준 프로토콜로 간주된다.

TCP는 신뢰할 수 없는 채널 위에 신뢰성을 구축한 추상 계층이다. 이는 네트워크 통신 구현에 필요한 유실 데이터 재전송, 전송 순서 확인, 혼잡 제어 및 회피 데이터 무결성 확인 같은 복잡한 기능을 투명하게 처리하여 애플리케이션 구현을 한결 쉽게 만들어준다. TCP 스트림의 특징 중 하나가, 전송된 모든 바이트(byte)는 수신된 모든 바이트와 한 치의 오차 없이 동일하며, 클라이언트에서 전송한 바이트 순서대로 도착한다는 것이다. 이렇듯 TCP는 신속한 데이터 전송보다는 정확한 데이터의 전송에 더 특화되어 있다. 사실 이러한 점 때문에 브라우저의 웹 성능을 최적화하는 데에 어느 정도 문제를 야기하기도 한다.

HTTP 표준은 전송 프로토콜로서 오직 TCP만을 명시하고 있지는 않다. 우리가 원한다면 HTTP를 유저 데이터그램 소켓(User Datagram Protocol, UDP)이나 우리가 원하는 다른 어떤 프로토콜을 사용해도 된다. 그러나 실제로 오늘날 모든 HTTP 트래픽은 전부 TCP를 통해 전송되고 있다. TCP 자체적으로 많은 훌륭한 기능들을 가지고 있기 때문이다.

## 3-Way 핸드셰이크

모든 TCP 연결은 3-Way 핸드셰이크로부터 시작된다. 클라이언트와 서버가 애플리케이션 데이터를 주고받으려면 먼저 시작 패킷의 시퀀스 번호와 현재 연결과 관련한 여러 변수의 값을 상호 합의해야 한다. 순서 번호는 보안상의 이유로 양쪽에서 무작위로 뽑는다.

- *SYN*: 클라이언트가 무작위로 시퀀스 번호 x를 고르고 SYN 패킷을 보낸다. 그 밖의 다른 TCP 플래그나 옵션 값들을 포함할 수 있다.
- *SYN ACK*: 서버가 시퀀스 번호 x를 1만큼 증가시키고, 무작위로 시퀀스 번호 y를 고른다. 서버 또한 플래그와 옵션 값들을 추가한 후 응답을 보낸다.
- *ACK*: 클라이언트가 x와 y를 모두 1만큼 증가시킨 후 마지막 ACK 패킷을 보냄으로써 핸드셰이크 과정을 종료한다.

3-Way 핸드셰이크가 끝나면 애플길케이션 데이터가 클라이언트와 서버 사이에 오고 갈 수 있게 된다. 클라이언트는 ACK 패킷 뒤에 바로 데이터 패킷을 보낼 수 있고, 서버는 ACK 패킷이 도착해야만 데이터 패킷을 보낼 수 있다. 이러한 초기 절차는 모든 TCP 연결에 다 해당되며, TCP를 이용하는 모든 네트워크 애플리케이션의 성능에 중요한 영향을 미친다. 새로 맺어지는 모든 커넥션은 데이터가 전송되기도 전에 서버와 클라이언트 간에 왕복 레이턴시를 한번 겪게 된다.

3 Way 핸드셰이크로 인해 발생하는 지연이 크기 때문에, 새로운 TCP 커넥션을 맺는 것보다 기존에 연결되어 있는 TCP 커넥션을 재사용하는 것이 TCP에서 작동하는 애플리케이션을 최적화하는 데에 아주 중요한 역할을 한다.

> **TCP Fast Open**
>
> TCP 핸드셰이크는 웹 브라우징 레이턴시의 주된 이유다. 여러 호스트로부터 수십 개에서 수백 개의 리소스를 얻어오기 위해 짧은 TCP 플로가 빈번하게 발생하기 때문이다.
>
> TCP Fas Open(TFO)은 이와 같이 새로운 TCP 커넥션을 생성할 때마다 발생하는 레이턴시 문제를 최소화하기 위해 만들어진 매커니즘이다. 구글에서 수행한 트래픽 분석과 네트워크 애뮬레이션을 토대로 연구한 결과, TFO는 SYN 패킷 안에서 데이터 전송을 가능케 함으로써 HTTP 트랜잭션 네트워크 레이턴시를 15% 만큼 줄였고 전체 페이지 로딩 시간은 평균 10% 만큼, 레이턴시가 높았던 몇몇의 경우에는 40%까지도 줄일 수 있었다.
>
> Linux 3.7+ 커널에서는 서버와 클라이언트 모두 TFO를 지원하고 있으므로 새로운 클라이언트와 서버에게는 좋은 옵션이 될 수 있다. 하지만 TFO 역시 모든 문제를 해결할 수 있는 것은 아니다. TFO가 3-Way 핸드셰이크로 인한 왕복 패널티를 줄이는 데 유용하지만, TFO는 특정 조건이 충족되어야만 사용할 수 있다. 즉, SYN 패킷 내에는 데이터 페이로드의 크기에 한계가 있기 때문에 특정 타입의 HTTP 요청만 전송할 수 있으며, 암호화된 쿠키를 필요로 하기 때문에 반복적으로 커넥션을 맺을 때 활용할 수 있다.

## 혼잡 제어 및 회피

혼잡 붕괴(congestion collapse)는 대역폭이 서로 다른 채널들로 구성된 네트워크에 영향을 주는 현상이다.

### 흐름 제어(Flow Control)

흐름 제어는 송신자가 수신자에게 처리하지 못할 만큼의 많은 데이터를 전송하는 것을 미리 방지하는 매커니즘이다.

### 느린 시작(Slow-Start)

TCP 내에 흐름 제어가 있음에도 불구하고 네트워크 혼잡 붕괴는 1980년 후반에 현실적인 문제로 다가왔다. 흐름 제어는 송신자가 수신자에게 부담을 주지 않도록 하는 기능을 하고 있었으나, 네트워크 자체에 주는 부담을 막는 메커니즘은 존재하지 않았다. 송신자나 수신자 모두 새로운 커넥션이 생성될 때 허용된 대역폭이 얼마 만큼인지 알지 못하기 때문에, 수시로 변화하는 네트워크 상태에 따라 대역폭을 가늠하고 그에 따라 데이터의 전송속도를 조절하는 메커니즘이 필요했다.

1988년, 이러한 문제를 해결하기 위한 몇 가지 알고리즘이 소개되었다. 느린 시작(slow-start), 혼잡 회피(congestion avoidance), 빠른 재전송(fast retransmit), 그리고 빠른 복구(fast recoverty)가 그것들이다. 이 네 가지 알고리즘은 신속하게 TCP 스펙의 필수적인 부분으로 자리잡았다.

클라이언트와 서버 간의 허용량을 가늠하는 유일한 방법은 실제로 데이터를 교환하면서 허용량을 측정하는 것뿐이다. 이것이 바로 느린 시작이 하는 일이다. 일단 서버가 각 TCP 커넥션마다 새 혼잡 윈도(cwnd) 변수를 만들고 그 값을 시스템에서 정해진 안전한 수치로 설정한다.

> **혼잡 윈도 크기(cwnd)**
>
> 클라이언트로부터 응답 확인(ACK) 신호를 받기 전에 송신자 측에서 지정하는 최대 송신 데이터량

cwnd 변수는 송신자와 수신자 간에 값이 교환되거나 서로 통지되지 않는다. 더 나아가 여기에 새로운 규칙이 적용되는데 송신자와 수신자 사이에서 이동 중인(ACK 신호를 받지 않은) 데이터의 최대치는 rwnd와 cwnd 값 중 작은 값이 된다.

브라우저 애플리케이션을 개발할 때에 느린 시작(slow-start)을 중요하게 고려해야 할 이유는 무엇일까? 그것은 TCP상에서 동작하는 HTTP나 다른 모든 애플리케이션 프로토콜들은 주어진 대역폭과 관계없이 무조건 이 느린 시작 단계를 거쳐야 하기 때문이다. 모든 TCP 커넥션에서 우리는 곧바로 링크의 최대 허용량을 활용할 수가 없다.

대신 우리는 작은 혼잡 윈도 크기부터 시작해서 데이터가 매번 왕복할 때마다 윈도 사이즈를 두 배씩 늘려 나가는 것이다.

혼잡 윈도 크기를 증가시키는데 걸리는 시간을 단축시키기 위해서는 클라이언트와 서버 간의 왕복 시간을 줄이는 방법이 있다. 예를 들어 서버의 위치를 클라이언트에 보다 지역적으로 가까운 곳에 배치시킨다든지 말이다. 혹은 초기 혼잡 윈도 크기 값을 새 RFC 6928에 정의한 10 세그먼트로 늘릴 수도 있다.

### 혼잡 회피

느린 시작(slow-start)은 작은 윈도 크기로 커넥션을 시작한 후, 데이터가 한 바퀴 왕복할 때마다 한 번에 이동하는 데이터 양은 두 배로 늘어난다. 이 과정은 이동하는 데이터 양이 수신자의 흐름 제어 윈도, 즉 시스템에서 설정된 혼잡 임계치(ssthresh) 크기를 넘어서기 전까지 계속되거나 패킷이 손실될 때까지 계속된다. 그 이후부터는 혼잡 회피 알고리즘이 발동한다.

혼잡 회피에서 암묵적으로 판단하기에 패킷 손실이 일어났다는 것은 네트워크 혼잡이 일어났다는 신호다. 이동 경로의 어딘가에서 정체가 일어난 링크나 라우터가 패킷을 누락시켰을 것이다. 그래서 우리는 네트워크에 부담을 덜어 주고 더 이상의 패킷 손실을 막기 위해 윈도 사이즈를 조정해야 하는 것이다.

일단 혼잡 윈도가 리셋되면, 혼잡 회피는 더 이상의 손실을 최소화 하기 위해 얼마나 윈도 크기를 늘려야 할지를 지정한다. 이후 어느 시점에서 패킷 손실이 다시 한 번 일어나면 이 과정을 다시 한 번 반복한다.

## 대역폭 지연 곱(Bandwidth-Delay Product)

데이터 링크의 허용량과 종단 간 지연을 곱한 값으로, 결과값은 ACK를 받지 않고 이동할 수 있는 데이터의 최대 양이다.

## Head-of-Line(HOL) 블로킹

TCP가 널리 쓰이는 것은 사실이지만 모든 경우에서 최고의 선택이라고는 할 수 없다. 특히나 전송 순서 확인, 안정적인 패킷 전송과 같은 기능들은 경우에 따라 꼭 필요한 게 아니며, 불필요한 지연이나 성능에 좋지 않은 영향을 끼칠 수도 있다.

이에 대한 이유를 알기 위해서는, 모든 TCP 패킷이 전송될 때 고유의 시퀀스 번호를 가지며 수신자에게 주어진 순서대로 전달되어야 한다는 사실을 기억해야 한다. 만약 수신자에게 이동 중인 패킷 하나가 소실되면 다른 모든 패킷들은 소실된 패킷이 재전송될 때까지 수신자 쪽 TCP 버퍼에서 대기해야만 한다. 이러한 과정이 TCP 계층 내에서 이루어지기 때문에 애플리케이션에서는 TCP의 데이터 재전송 여부나 큐에 들어있는 패킷 버퍼를 살펴볼 수가 없고, 모든 시퀀스가 모두 도착하고 나서야 데이터에 접근할 수 있다. 애플리케이션 입장에서는 그저 소켓에서 데이터를 읽으려 했을 때 전달 지연을 겪게 될 뿐이다. 이러한 현상을 TCP head-of-line (HOL) 블로킹이라 한다.

HOC 블로킹의 장점은, 애플리케이션이 패킷의 재배치나 재조합에 관여할 필요가 없기 때문에 애플리케이션의 코드 자체는 훨씬 간단해진다는 것이다. 그러나 단점은 패킷이 도착하는 시간이 들쭉날쭉해서 레이턴시를 예측하기 어렵다는 점이다. 이러한 현상을 지터(jitter)라고 하는데, 지터는 애플리케이션의 성능에 좋지 않은 영향을 끼칠 수 있다.

어떤 애플리케이셔의 경우는 전송의 신뢰성이나 순서를 보장하는 기능이 필요하지 않을 수 있다. 만약 모든 패킷이 독자적인 메시지라면 패킷의 순서를 보장하는 방법이 전혀 필요치 않고, 모든 메시지가 이전 메시지를 덮어 쓰게 된다면 전송의 신뢰성 기능 역시 전혀 필요 없게 된다. 안타깝지만 TCP에서는 이러한 설정을 변경할 수 없다. 모든 패킷은 무조건 시퀀스 번호 순서대로 전달된다.

패킷 전달 순서에 상관이 없고 패킷 손실이 발생해도 별 문제가 없으나, 레이턴시나 지터에 예민한 애플리케이션의 경우에는 UDP와 같은 다른 프로토콜을 사용하는 것이 더 좋을 것이다.

## TCP의 최적화

각 TCP 알고리즘과 피드백 메커니즘의 세부적인 원리는 계속해서 발전하겠지만 TCP의 핵심 원리와 그것이 미치는 영향은 바뀌지 않는다.

- TCP 3-Way 핸드셰이크는 왕복 시간 한 번만큼의 레이턴시를 발생시킨다.
- TCP 느린 시작(slow-start)은 커넥션이 새로 만들어질 때 항상 발생한다.
- TCP 흐름 제어와 혼잡 제어는 모든 커넥션의 처리량을 조절한다.
- TCP 처리량은 현재 혼잡 윈도 크기에 의해 결정된다.

### 서버 설정 조정하기

TCP의 특정 버퍼와 타임아웃 변수를 조정하기 전에, 일단 사용하는 호스트를 최신 시스템 버전으로 업그레이드하는 것이 좋다. TCP를 효과적으로 활용하는 방법과 TCP의 성능을 좌우하는 알고리즘은 갈수록 진화하고 있으나, 이들을 사용하기 위해서는 최신 커널을 설치해야 한다.

- TCP의 초기 혼잡 윈도 크기 증가
- 느린 시작(Slow-Start) 다시 시작하기
- 윈도 스케일링 (RFC 1323)
- TCP Fast Open

### 애플리케이션의 동작 튜닝하기

TCP의 성능을 튜닝하면 서버와 클라이언트에게 각 커넥션당 최고의 처리량과 레이턴시를 얻을 수 있다. 하지만 애플리케이션이 새 커넥션, 혹은 기존 커넥션을 어떻게 사용하느냐가 더 큰 영향을 끼칠 수도 있다.

- 비트를 보내지 않는 것보다 빠른 방법은 없다. 즉, 더 적은 수의 비트를 전송하라.
- 데이터를 빨리 이동하게 할 수는 없지만 이동 거리를 줄일 수는 있다.
- TCP 커넥션 재사용은 성능 향상에 매우 중요하다.

### 성능 체크리스트

최적화를 위해 체크해야 할 짧은 리스트를 소개한다.

- 서버 커널을 최신버전으로 업그레이드하라.(Linux 3.2+)
- 혼잡 윈도(cwnd) 크기는 10으로 설정하라.
- 유휴 상태 후 느린 시작(slow-start)을 비활성화하라.
- 윈도 스케일링을 활성화하라.
- 불필요한 데이터 전송을 피하라.
- 전송 데이터를 압축하라.
- 서버를 사용자와 가까운 곳에 배치하여 왕복 시간을 줄여라.
- 기존 TCP 커넥션을 가능한 한 재사용하라.

## QNA

- IPv4와 IPv6이라는 명칭의 뜻
- 3-Way 핸드셰이크 과정에서 시퀀스 번호를 증가시키는 이유는?
- 혼잡 제어와 혼잡 붕괴
- 혼잡 붕괴(congestion collapse)
- 리시브 윈도(rwnd), 혼잡 윈도(cwnd)
- 윈도 스케일링(RFC 1323)
- 3-Way 핸드셰이크는 새 TCP 커넥션이 만들어지는 순간에 한 번만 일어나는 것이 아닌지? "ACK 신호를 받을 때마다 ~"의 의미?(23페이지)
- 네트워크 세그먼트
- 서버 커널, 서버 운영에 리눅스가 꼭 필요할까?
- TCP 커넥션을 재사용한다는 것의 의미는?

## 참고

* [네트워킹과 웹 성능 최적화 기법 | 알리아 그리고릭, 인사이트](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&linkClass=3309&barcode=9788966261659)
